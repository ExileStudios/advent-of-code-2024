<?php
declare(strict_types=1);

/**
 * Advent of Code 2024 - Day 22: Monkey Market
 * 
 * Simulates pseudorandom sequence generation for monkey buyers and identifies
 * optimal sequences to maximize banana profits.
 * 
 */
final class MonkeyMarket
{    
    /**
     * @var array<int> List of initial secret numbers for each buyer.
     */
    private array $initialSecrets;

    /**
     * Constructor to initialize the MonkeyMarket with input data.
     *
     * @param string $inputFile Path to the input file containing initial secrets.
     * @throws RuntimeException If the file cannot be read.
     */
    public function __construct(string $inputFile)
    {
        $this->initialSecrets = $this->loadInitialSecrets($inputFile);
    }

    /**
     * Loads initial secret numbers from the input file.
     *
     * @param string $inputFile Path to the input file.
     * @return array<int> Array of initial secret numbers.
     * @throws RuntimeException If the file cannot be read.
     */
    private function loadInitialSecrets(string $inputFile): array
    {
        $content = file_get_contents($inputFile);
        if ($content === false) {
            throw new RuntimeException("Unable to read input file: $inputFile");
        }

        return array_filter(array_map('intval', explode("\n", trim($content))));
    }

    /**
     * Simulates the sequence of 2000 secret numbers for a given initial value.
     *
     * @param int $initialSecret Initial secret number.
     * @return array<int> Array of generated secret numbers including the initial secret.
     */
    private function simulateSecretSequence(int $initialSecret): array
    {
        $secret = $initialSecret;
        $modulo = 16777216;
        $secrets = [];

        // Pre-allocate array for better performance
        $secrets = array_fill(0, 2001, 0);
        $secrets[0] = $secret;

        for ($i = 0; $i < 2000; $i++) {
            $multiplyResult = ($secret * 64) % $modulo;
            $secret = ($secret ^ $multiplyResult) % $modulo;
            
            $divideResult = (int)($secret / 32);
            $secret = ($secret ^ $divideResult) % $modulo;
            
            $multiplyResult = ($secret * 2048) % $modulo;
            $secret = ($secret ^ $multiplyResult) % $modulo;
            
            $secrets[$i + 1] = $secret;
        }

        return $secrets;
    }

    /**
     * Computes the sum of the 2000th secret numbers generated by all buyers.
     *
     * @return int The sum of the 2000th secret numbers.
     */
    public function compute2000thSecretSum(): int
    {
        $sum = 0;

        foreach ($this->initialSecrets as $secret) {
            $sum += $this->simulateSecretSequence($secret)[2000];
        }

        return $sum;
    }

    /**
     * Extracts the prices from the given secrets.
     *
     * @param array<int> $secrets Array of secret numbers.
     * @return array<int> Array of prices derived from the secrets.
     */
    private function getPrices(array $secrets): array
    {
        return array_map(fn(int $secret) => $secret % 10, $secrets);
    }

    /**
     * Computes the changes in prices.
     *
     * @param array<int> $prices Array of prices.
     * @return array<int> Array of price changes.
     */
    private function getPriceChanges(array $prices): array
    {
        $changes = [];
        for ($i = 1, $n = count($prices); $i < $n; $i++) {
            $changes[] = $prices[$i] - $prices[$i - 1];
        }
        return $changes;
    }

    /**
     * Determines the best sequence of price changes to maximize bananas.
     *
     * @return int The maximum number of bananas achievable.
     */
    public function findBestSequenceForBananas(): int 
    {
        $sequences = [];

        foreach ($this->initialSecrets as $secret) {
            $secrets = $this->simulateSecretSequence($secret);
            $prices = $this->getPrices($secrets);
            $changes = $this->getPriceChanges($prices);
            
            for ($i = 0; $i <= count($changes) - 4; $i++) {
                $sequence = implode(',', array_slice($changes, $i, 4));
                
                if (!isset($sequences[$sequence][$secret])) {
                    $sequences[$sequence][$secret] = $prices[$i + 4];
                }
            }
        }

        $maxBananas = 0;
        foreach ($sequences as $prices) {
            $maxBananas = max($maxBananas, array_sum($prices));
        }
        
        return $maxBananas;
    }
}

// Main execution
$inputFile = $argv[1] ?? (__DIR__ . '/input.txt');

try {
    ini_set('memory_limit', '512M');
    $market = new MonkeyMarket($inputFile);
    echo "Sum of 2000th secret numbers: " . $market->compute2000thSecretSum() . PHP_EOL;
    echo "Max bananas possible: " . $market->findBestSequenceForBananas() . PHP_EOL;
} catch (RuntimeException $e) {
    echo "Error: " . $e->getMessage() . PHP_EOL;
}
